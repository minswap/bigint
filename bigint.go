package bigint

import "math/big"

type BigInt struct {
	i big.Int
}

func New(x int64) BigInt {
	return BigInt{*big.NewInt(x)}
}

// FromString return a BigInt from the value of s, interpreted in the given base,
// and returns result and a boolean indicating success. The entire string
// (not just a prefix) must be valid for success. If FromString fails,
// the returned value is 0.
//
// The base argument must be 0 or a value between 2 and MaxBase.
// For base 0, the number prefix determines the actual base: A prefix of
// ``0b'' or ``0B'' selects base 2, ``0'', ``0o'' or ``0O'' selects base 8,
// and ``0x'' or ``0X'' selects base 16. Otherwise, the selected base is 10
// and no prefix is accepted.
//
// For bases <= 36, lower and upper case letters are considered the same:
// The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35.
// For bases > 36, the upper case letters 'A' to 'Z' represent the digit
// values 36 to 61.
//
// For base 0, an underscore character ``_'' may appear between a base
// prefix and an adjacent digit, and between successive digits; such
// underscores do not change the value of the number.
// Incorrect placement of underscores is reported as an error if there
// are no other errors. If base != 0, underscores are not recognized
// and act like any other character that is not a valid digit.
//
func FromString(s string, base int) (BigInt, bool) {
	x := new(big.Int)
	_, ok := x.SetString(s, base)
	if !ok {
		return New(0), ok
	}
	return BigInt{*x}, ok
}

// IsInt64 reports whether x can be represented as an int64.
func (x BigInt) IsInt64() bool {
	return x.i.IsInt64()
}

// Int64 returns the int64 representation of x.
// If x cannot be represented in an int64, the result is undefined.
func (x BigInt) Int64() int64 {
	return x.i.Int64()
}

// IsUint64 reports whether x can be represented as a uint64.
func (x BigInt) IsUint64() bool {
	return x.i.IsUint64()
}

// Uint64 returns the uint64 representation of x.
// If x cannot be represented in a uint64, the result is undefined.
func (x BigInt) Uint64() uint64 {
	return x.i.Uint64()
}

// Text returns the string representation of x in the given base.
// Base must be between 2 and 62, inclusive. The result uses the
// lower-case letters 'a' to 'z' for digit values 10 to 35, and
// the upper-case letters 'A' to 'Z' for digit values 36 to 61.
// No prefix (such as "0x") is added to the string.
func (x BigInt) Text(base int) string {
	return x.i.Text(base)
}

// String returns the decimal representation of x as generated by
// x.Text(10).
func (x BigInt) String() string {
	return x.i.String()
}

// Sign returns:
//
//	-1 if x <  0
//	 0 if x == 0
//	+1 if x >  0
//
func (x BigInt) Sign() int {
	return x.i.Sign()
}

// Neg return -x
func (x BigInt) Neg() BigInt {
	return BigInt{*new(big.Int).Neg(&x.i)}
}

// Add returns x+y
func (x BigInt) Add(y BigInt) BigInt {
	return BigInt{*new(big.Int).Add(&x.i, &y.i)}
}

// Sub returns x-y
func (x BigInt) Sub(y BigInt) BigInt {
	return BigInt{*new(big.Int).Sub(&x.i, &y.i)}
}

// Mul returns x*y
func (x BigInt) Mul(y BigInt) BigInt {
	return BigInt{*new(big.Int).Mul(&x.i, &y.i)}
}

// MulRange returns the product of all integers
// in the range [a, b] inclusively.
// If a > b (empty range), the result is 1.
func MulRange(a, b int64) BigInt {
	return BigInt{*new(big.Int).MulRange(a, b)}
}

// QuoRem returns the quotient x/y and the remainder x%y for y != 0.
// If y == 0, a division-by-zero run-time panic occurs.
//
// QuoRem implements T-division and modulus (like Go):
//
//	q = x/y      with the result truncated to zero
//	r = x - y*q
//
// (See Daan Leijen, ``Division and Modulus for Computer Scientists''.)
// See DivMod for Euclidean division and modulus (unlike Go).
//
func (x BigInt) QuoRem(y BigInt) (BigInt, BigInt) {
	rem := new(big.Int)
	quo, rem := new(big.Int).QuoRem(&x.i, &y.i, rem)
	return BigInt{*quo}, BigInt{*rem}
}

// Quo returns the quotient x/y for y != 0.
// If y == 0, a division-by-zero run-time panic occurs.
// Quo implements truncated division (like Go); see QuoRem for more details.
func (x BigInt) Quo(y BigInt) BigInt {
	return BigInt{*new(big.Int).Quo(&x.i, &y.i)}
}

// Rem returns the remainder x%y for y != 0.
// If y == 0, a division-by-zero run-time panic occurs.
// Rem implements truncated modulus (like Go); see QuoRem for more details.
func (x BigInt) Rem(y BigInt) BigInt {
	return BigInt{*new(big.Int).Rem(&x.i, &y.i)}
}

// DivMod returns the quotient x div y and the modulus x mod y for y != 0.
// If y == 0, a division-by-zero run-time panic occurs.
//
// DivMod implements Euclidean division and modulus (unlike Go):
//
//	q = x div y  such that
//	m = x - y*q  with 0 <= m < |y|
//
// (See Raymond T. Boute, ``The Euclidean definition of the functions
// div and mod''. ACM Transactions on Programming Languages and
// Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992.
// ACM press.)
// See QuoRem for T-division and modulus (like Go).
//
func (x BigInt) DivMod(y BigInt) (BigInt, BigInt) {
	mod := new(big.Int)
	div, mod := new(big.Int).DivMod(&x.i, &y.i, mod)
	return BigInt{*div}, BigInt{*mod}
}

// Div returns the quotient x/y for y != 0.
// If y == 0, a division-by-zero run-time panic occurs.
// Div implements Euclidean division (unlike Go); see DivMod for more details.
func (x BigInt) Div(y BigInt) BigInt {
	return BigInt{*new(big.Int).Div(&x.i, &y.i)}
}

// Mod returns the modulus x%y for y != 0.
// If y == 0, a division-by-zero run-time panic occurs.
// Mod implements Euclidean modulus (unlike Go); see DivMod for more details.
func (x BigInt) Mod(y BigInt) BigInt {
	return BigInt{*new(big.Int).Mod(&x.i, &y.i)}
}

func (x BigInt) And(y BigInt) BigInt {
	return BigInt{*new(big.Int).And(&x.i, &y.i)}
}

func (x BigInt) AndNot(y BigInt) BigInt {
	return BigInt{*new(big.Int).AndNot(&x.i, &y.i)}
}

func (x BigInt) Or(y BigInt) BigInt {
	return BigInt{*new(big.Int).Or(&x.i, &y.i)}
}

func (x BigInt) Xor(y BigInt) BigInt {
	return BigInt{*new(big.Int).Xor(&x.i, &y.i)}
}

func (x BigInt) Not(y BigInt) BigInt {
	return BigInt{*new(big.Int).Not(&x.i)}
}

// Bit returns the value of the i'th bit of x. That is, it
// returns (x>>i)&1. The bit index i must be >= 0.
func (x BigInt) Bit(i int) uint {
	return x.i.Bit(i)
}

// BitLen returns the length of the absolute value of x in bits.
// The bit length of 0 is 0.
func (x BigInt) BitLen() int {
	return x.i.BitLen()
}

// Bytes returns the absolute value of x as a big-endian byte slice.
//
// To use a fixed length slice, or a preallocated one, use FillBytes.
func (x BigInt) Bytes() []byte {
	return x.i.Bytes()
}

// Cmp compares x and y and returns:
//
//   -1 if x <  y
//    0 if x == y
//   +1 if x >  y
//
func (x BigInt) Cmp(y BigInt) int {
	return x.i.Cmp(&y.i)
}

// CmpAbs compares the absolute values of x and y and returns:
//
//   -1 if |x| <  |y|
//    0 if |x| == |y|
//   +1 if |x| >  |y|
//
func (x BigInt) CmpAbs(y BigInt) int {
	return x.i.CmpAbs(&y.i)
}

func (x BigInt) EQ(y BigInt) bool {
	return x.i.Cmp(&y.i) == 0
}

func (x BigInt) LT(y BigInt) bool {
	return x.i.Cmp(&y.i) < 0
}

func (x BigInt) LTE(y BigInt) bool {
	return x.i.Cmp(&y.i) <= 0
}

func (x BigInt) GT(y BigInt) bool {
	return x.i.Cmp(&y.i) > 0
}

func (x BigInt) GTE(y BigInt) bool {
	return x.i.Cmp(&y.i) >= 0
}

func (x BigInt) Abs() BigInt {
	return BigInt{*new(big.Int).Abs(&x.i)}
}

func (x BigInt) Sqrt() BigInt {
	return BigInt{*new(big.Int).Sqrt(&x.i)}
}

// GCD returns the greatest common divisor of a and b.
// If x or y are not nil, GCD sets their value such that z = a*x + b*y.
//
// a and b may be positive, zero or negative. (Before Go 1.14 both had
// to be > 0.) Regardless of the signs of a and b, result is always >= 0.
//
// If a == b == 0, GCD sets z = x = y = 0.
//
// If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.
//
// If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0.
func GCD(x, y *BigInt, a, b BigInt) BigInt {
	return BigInt{*new(big.Int).GCD(&x.i, &y.i, &a.i, &b.i)}
}

// Binomial returns the binomial coefficient of (n, k).
func Binomial(n, k int64) BigInt {
	return BigInt{*new(big.Int).Binomial(n, k)}
}

// MarshalText implements the text.Marshaler interface.
func (x BigInt) MarshalText() ([]byte, error) {
	return x.i.MarshalText()
}

// UnmarshalText implements the text.Unmarshaler interface.
func (x *BigInt) UnmarshalText(text []byte) error {
	return x.i.UnmarshalText(text)
}

// MarshalJSON implements the json.Marshaler interface.
func (x BigInt) MarshalJSON() ([]byte, error) {
	return x.i.MarshalJSON()
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (x *BigInt) UnmarshalJSON(text []byte) error {
	return x.i.UnmarshalJSON(text)
}

// GobEncode implements the gob.GobEncoder interface.
func (x BigInt) GobEncode() ([]byte, error) {
	return x.i.GobEncode()
}

// GobDecode implements the gob.GobDecoder interface.
func (x *BigInt) GobDecode(buf []byte) error {
	return x.i.GobDecode(buf)
}
